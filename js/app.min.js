angular.module("travis-wall", [ "ngRoute", "angularSpinner", "wu.masonry" ]);

angular.module("travis-wall").config([ "$routeProvider", function($routeProvider) {
    "use strict";
    $routeProvider.when("/", {
        controller: "HomeController",
        templateUrl: "partials/home.html"
    }).when("/wall", {
        controller: "WallController",
        templateUrl: "partials/wall.html"
    });
} ]);

angular.module("travis-wall").controller("HomeController", [ "$scope", "$location", "TravisRepository", function($scope, $location, TravisRepository) {
    "use strict";
    $scope.user = new User();
    $scope.login = function() {
        TravisRepository.get($scope.user).then(function(repositories) {
            if (repositories.length) {
                if ($scope.user.token !== "") {
                    $location.search("travisToken", $scope.user.travisToken);
                }
                $location.path("/wall");
            }
        });
    };
} ]);

angular.module("travis-wall").controller("WallController", [ "$scope", "$routeParams", "$interval", "$location", "TravisRepository", function($scope, $routeParams, $interval, $location, TravisRepository) {
    "use strict";
    $scope.user = new User(null, null, $routeParams.travisToken);
    var _redirect = function() {
        $location.search("travisToken", null);
        $location.path("/");
    };
    var _wall = function() {
        TravisRepository.get($scope.user).then(function(repositories) {
            if (!repositories.length) {
                _redirect();
            }
            $scope.user.repositories = repositories;
        }, _redirect);
    };
    _wall();
    var _interval = $interval(_wall, 15e3);
    $scope.$on("$destroy", function() {
        $interval.cancel(_interval);
    });
} ]);

angular.module("travis-wall").directive("ngTravisLogin", [ "$timeout", "TravisRepository", function($timeout, TravisRepository) {
    "use strict";
    return {
        require: "^form",
        templateUrl: "partials/travis-login.html",
        link: function(scope, element, attributes, control) {
            var _user = new User();
            var _timeout;
            function _initDetection() {
                control.$detection = true;
                _setValidity(true);
            }
            function _initProcessing() {
                control.$detection = false;
                control.$processing = true;
            }
            function _setValidity(validity) {
                control.$setValidity("travis", validity);
                control.$processing = false;
            }
            var _callback = function() {
                $timeout.cancel(_timeout);
                _initDetection();
                _user.token = element.find("#github-token").val().trim();
                _timeout = $timeout(function() {
                    _initProcessing();
                    TravisRepository.get(_user).then(function(repositories) {
                        _setValidity(repositories.length > 0);
                    }, function() {
                        _setValidity(false);
                    });
                }, 1e3);
            };
            _initDetection();
            element.find("#github-token").on("keyup", _callback);
        }
    };
} ]);

angular.module("travis-wall").factory("TravisApi", [ "$http", "$q", function($http, $q) {
    "use strict";
    var TRAVIS_ORG_HOST = "api.travis-ci.org";
    var TRAVIS_COM_HOST = "api.travis-ci.com";
    var TRAVIS_ORG_URL = "https://" + TRAVIS_ORG_HOST;
    var TRAVIS_COM_URL = "https://" + TRAVIS_COM_HOST;
    var TRAVIS_AUTH_GITHUB_URL = "https://api.travis-ci.com/auth/github";
    function exchangeGithubToken(user) {
        return $http({
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            data: {
                github_token: user.token
            },
            url: TRAVIS_AUTH_GITHUB_URL
        }).then(function(response) {
            return response.data.access_token;
        });
    }
    function _createHttp(user, type, useToken) {
        var tokenPromise;
        if (useToken && !user.travisToken) {
            tokenPromise = exchangeGithubToken(user);
        } else {
            tokenPromise = $q(function(resolve) {
                resolve(user.travisToken);
            });
        }
        return tokenPromise.then(function(t) {
            var headers = {
                Accept: "application/vnd.travis-ci.2+json"
            };
            if (t) {
                user.travisToken = t;
                headers.Authorization = [ "token", t ].join(" ");
            }
            return $http({
                method: "GET",
                headers: headers,
                url: (useToken ? TRAVIS_COM_URL : TRAVIS_ORG_URL) + "/repos"
            }).then(function(resp) {
                return resp.data.repos;
            });
        });
    }
    function _createHttpByOwner(user, useToken) {
        return _createHttp(user, "owner_name", useToken);
    }
    function _createHttpByMember(user, useToken) {
        return _createHttp(user, "member", useToken);
    }
    return {
        getByOwnerForOrg: function(user) {
            return _createHttpByOwner(user, false);
        },
        getByMemberForOrg: function(user) {
            return _createHttpByMember(user, false);
        },
        getByOwnerForCom: function(user) {
            return _createHttpByOwner(user, true);
        },
        getByMemberForCom: function(user) {
            return _createHttpByMember(user, true);
        }
    };
} ]);

angular.module("travis-wall").factory("TravisRepository", [ "$q", "TravisApi", function($q, TravisApi) {
    "use strict";
    function _getForOrg(user) {
        return _getByMemberForOrg(user).then(function(repositories) {
            if (repositories.length) {
                return repositories;
            }
            return _getByOwnerForOrg(user);
        });
    }
    function _getForCom(user) {
        return _getByMemberForCom(user).then(function(repositories) {
            if (repositories.length) {
                return repositories;
            }
            return _getByOwnerForCom(user);
        });
    }
    function _getByMemberForOrg(user) {
        var _deferred = $q.defer();
        TravisApi.getByMemberForOrg(user).then(function(repositories) {
            _deferred.resolve(_setPrivate(repositories, false));
        }).catch(function(error) {
            _deferred.reject(error);
        });
        return _deferred.promise;
    }
    function _getByOwnerForOrg(user) {
        var _deferred = $q.defer();
        TravisApi.getByOwnerForOrg(user).then(function(repositories) {
            _deferred.resolve(_setPrivate(repositories, false));
        }).catch(function(error) {
            _deferred.reject(error);
        });
        return _deferred.promise;
    }
    function _getByMemberForCom(user) {
        var _deferred = $q.defer();
        TravisApi.getByMemberForCom(user).then(function(repositories) {
            _deferred.resolve(_setPrivate(repositories, true));
        }).catch(function(error) {
            _deferred.reject(error);
        });
        return _deferred.promise;
    }
    function _getByOwnerForCom(user) {
        var _deferred = $q.defer();
        TravisApi.getByOwnerForCom(user).then(function(repositories) {
            _deferred.resolve(_setPrivate(repositories, true));
        }).catch(function(error) {
            _deferred.reject(error);
        });
        return _deferred.promise;
    }
    function _setPrivate(repositories, value) {
        for (var key in repositories) {
            repositories[key].private = value;
        }
        return repositories;
    }
    return {
        get: function(user) {
            return _getForCom(user).then(function(comRepositories) {
                return comRepositories;
            });
        }
    };
} ]);

function Repositories(collection) {
    "use strict";
    var _collection = [];
    function _indexOf(slug) {
        for (var key in _collection) {
            if (_collection[key].slug === slug) {
                return key;
            }
        }
    }
    var _that = {
        get all() {
            return _collection;
        },
        set all(repositories) {
            for (var repositoryKey in repositories) {
                var repository = repositories[repositoryKey];
                var index = _indexOf(repository.slug);
                if (index === undefined) {
                    _collection.push(new Repository(repository));
                } else if (!_collection[index].compare(repository)) {
                    _collection[index].data = repository;
                }
            }
        }
    };
    if (collection === undefined) {
        collection = [];
    }
    _that.all = collection;
    return _that;
}

function Repository(data) {
    "use strict";
    var TRAVIS_ORG_URL = "https://travis-ci.org";
    var TRAVIS_COM_URL = "https://magnum.travis-ci.com";
    var GITHUB_URL = "https://github.com";
    var _data;
    var _buildDuration;
    var _buildStartedAt;
    var _buildFinishedAt;
    var _that = {
        get BUILD_STATUS_CODE_PASSED() {
            return "passed";
        },
        get BUILD_STATUS_CODE_UNKNOWN() {
            return "unknown";
        },
        get BUILD_STATUS_CODE_ERRORED() {
            return "errored";
        },
        get BUILD_STATUS_CODE_FAILED() {
            return "failed";
        },
        get BUILD_STATUS_CODE_QUEUED() {
            return "queued";
        },
        get BUILD_STATUS_CODE_BUILDING() {
            return "building";
        },
        get BUILD_STATUS_CODE_UNTRACKED() {
            return "untracked";
        },
        get BUILD_STATUS_CODE_CANCELED() {
            return "canceled";
        },
        get id() {
            return this.data.id;
        },
        get private() {
            return this.data.active === "true";
        },
        get slug() {
            return this.data.slug;
        },
        get description() {
            return this.data.description;
        },
        get travisUrl() {
            return (this.private ? TRAVIS_COM_URL : TRAVIS_ORG_URL) + "/" + this.slug;
        },
        get githubUrl() {
            return GITHUB_URL + "/" + this.slug;
        },
        get buildId() {
            return this.data.last_build_id;
        },
        get buildUrl() {
            return this.travisUrl + "/builds/" + this.buildId;
        },
        get buildNumber() {
            return this.data.last_build_number;
        },
        get buildStatusCode() {
            switch (this.data.last_build_state) {
              case this.BUILD_STATUS_CODE_PASSED:
                return this.BUILD_STATUS_CODE_PASSED;

              case this.BUILD_STATUS_CODE_FAILED:
                return this.BUILD_STATUS_CODE_FAILED;

              case this.BUILD_STATUS_CODE_CANCELED:
                return this.BUILD_STATUS_CODE_CANCELED;

              default:
                if (this.buildId === null) {
                    return this.BUILD_STATUS_CODE_UNTRACKED;
                }
                if (this.buildStartedAt === null && this.buildFinishedAt === null) {
                    return this.BUILD_STATUS_CODE_QUEUED;
                }
                if (this.buildStartedAt !== null && this.buildFinishedAt === null) {
                    return this.BUILD_STATUS_CODE_BUILDING;
                }
                if (this.buildStartedAt !== null && this.buildFinishedAt !== null) {
                    return this.BUILD_STATUS_CODE_ERRORED;
                }
                return this.BUILD_STATUS_CODE_UNKNOWN;
            }
        },
        get buildDuration() {
            return _buildDuration;
        },
        get buildHumanDuration() {
            return this.buildDuration !== null ? this.buildDuration.from(0, true) : null;
        },
        get buildLanguage() {
            return this.data.last_build_language;
        },
        get buildStartedAt() {
            return _buildStartedAt;
        },
        get buildHumanStartedAt() {
            return this.buildStartedAt !== null ? this.buildStartedAt.fromNow() : null;
        },
        get buildFinishedAt() {
            return _buildFinishedAt;
        },
        get buildHumanFinishedAt() {
            return this.buildFinishedAt !== null ? this.buildFinishedAt.fromNow() : null;
        },
        get data() {
            return _data;
        },
        set data(data) {
            _data = data;
            _buildDuration = data.last_build_duration !== null ? moment(data.last_build_duration * 1e3) : null;
            _buildStartedAt = data.last_build_started_at !== null ? moment(data.last_build_started_at) : null;
            _buildFinishedAt = data.last_build_finished_at !== null ? moment(data.last_build_finished_at) : null;
        },
        compare: function(data) {
            function _compare(object, subject) {
                for (var key in object) {
                    if (object[key] !== subject[key]) {
                        return false;
                    }
                }
                return true;
            }
            return _compare(this.data, data) && _compare(data, this.data);
        }
    };
    _that.data = data;
    return _that;
}

function User(token, repositories, travisToken) {
    "use strict";
    if (token === undefined) {
        token = "";
    }
    if (travisToken === undefined) {
        travisToken = "";
    }
    var _token = token;
    var _repositories = new Repositories(repositories);
    var _travisToken = travisToken;
    return {
        get token() {
            return _token;
        },
        set token(token) {
            _token = token;
        },
        get travisToken() {
            return _travisToken;
        },
        set travisToken(travisToken) {
            _travisToken = travisToken;
        },
        get repositories() {
            return _repositories.all;
        },
        set repositories(repositories) {
            _repositories.all = repositories;
        }
    };
}